package daos

import (
	"encoding/json"
	"fmt"
	"kai-sec/internal/daos/models"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
)

func TestUpsertVulnerabilities(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock DB: %v", err)
	}
	defer db.Close()

	// Sample test data
	vulnerabilities := []models.VulnerabilityDAO{
		{
			ID:             "CVE-2024-1234",
			Severity:       "HIGH",
			CVSS:           8.5,
			Status:         "fixed",
			PackageName:    "openssl",
			CurrentVersion: "1.1.1t",
			FixedVersion:   "1.1.1u",
			Description:    "Buffer overflow vulnerability",
			PublishedDate:  time.Now(),
			Link:           "https://nvd.nist.gov/vuln/detail/CVE-2024-1234",
			RiskFactors:    []string{"Remote Code Execution", "High CVSS Score"},
		},
	}

	riskFactorsJSON, _ := json.Marshal(vulnerabilities[0].RiskFactors)

	// Expect INSERT INTO vulnerabilities
	mock.ExpectExec("INSERT INTO vulnerabilities").
		WithArgs(vulnerabilities[0].ID, "scan_001", vulnerabilities[0].Severity, vulnerabilities[0].CVSS,
			vulnerabilities[0].Status, vulnerabilities[0].PackageName, vulnerabilities[0].CurrentVersion,
			vulnerabilities[0].FixedVersion, vulnerabilities[0].Description, vulnerabilities[0].PublishedDate,
			vulnerabilities[0].Link, string(riskFactorsJSON)).
		WillReturnResult(sqlmock.NewResult(1, 1))

	// Run function
	err = UpsertVulnerabilities(db, "scan_001", vulnerabilities)
	if err != nil {
		t.Errorf("UpsertVulnerabilities failed: %v", err)
	}

	// Ensure all expectations were met
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %v", err)
	}
}

func TestUpsertVulnerabilities_Error(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock DB: %v", err)
	}
	defer db.Close()

	vulnerabilities := []models.VulnerabilityDAO{
		{
			ID:             "CVE-2024-9999",
			Severity:       "LOW",
			CVSS:           3.2,
			Status:         "active",
			PackageName:    "test-package",
			CurrentVersion: "1.0.0",
			FixedVersion:   "1.0.1",
			Description:    "Dummy vulnerability",
			PublishedDate:  time.Now(),
			Link:           "https://example.com",
			RiskFactors:    []string{"Information Disclosure"},
		},
	}

	// Expect INSERT but return an error
	mock.ExpectExec("INSERT INTO vulnerabilities").
		WillReturnError(fmt.Errorf("database error"))

	err = UpsertVulnerabilities(db, "scan_999", vulnerabilities)
	if err == nil {
		t.Errorf("expected error, got nil")
	}
}